trigger:
  branches:
    include:
    - main
pool:
  vmImage: 'windows-latest'
variables:
- name: configuration
  value: 'Release'
- name: buildOutput
  value: '$(Build.ArtifactStagingDirectory)'
- name: solution
  value: '**/*.sln'
- name: buildPlatform
  value: 'Any CPU'
- name: frontPath
  value: './EmployeeCrudAngular/EmployeeCrudAngular/EmployeeCrudAngular'
- name: backPath
  value: './EmployeeCrudApi'
- name: nodeVersion
  value: '18.x'
- name: ConnectedServiceName
  value: 'Azure Subscription 1'
- name: acrLoginServer
  value: 'vvingsoft3uccacr.azurecr.io'
- name: backImageName
  value: 'miwebapp'
- name: frontImageName
  value: 'miwebapp-prod'
- name: projectPath
  value: 'EmployeeCrudAngular'
- name: ResourceGroupName
  value: 'TPINGSW'
- name: backContainerInstanceNameQA
  value: 'vicky-container-back'
- name: backImageTag
  value: 'latest'
- name: container-cpu-api-qa
  value: 1
- name: container-memory-api-qa
  value: 1.5
- name: acrName
  value: 'VVIngSoft3UCCACR'
- name: frontContainerInstanceNameQA
  value: 'vicky-container-front'
- name: frontImageTag
  value: 'latest'
- name: container-cpu-front-qa
  value: 1
- name: container-memory-front-qa
  value: 1.5

stages:
- stage: BuildAndTest
  displayName: "Construir y Probar API y Front"
  jobs:
  - job: BuildDotnet
    displayName: "Construir y Probar API"
    pool:
      vmImage: 'windows-latest'
    steps:
    - task: DotNetCoreCLI@2
      displayName: 'Restaurar paquetes NuGet'
      inputs:
        command: restore
        projects: '$(solution)'
    - task: DotNetCoreCLI@2
      displayName: 'Build de Back'
      inputs:
        command: 'build'
        projects: 'EmployeeCrudApi/EmployeeCrudApi/EmployeeCrudApi.csproj'
        arguments: '--configuration $(buildConfiguration) --output $(buildOutput)/api  --self-contained false'
    - task: DotNetCoreCLI@2
      displayName: 'Publicar Back-End'
      inputs:
        command: publish
        publishWebProjects: true
        arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)'
        zipAfterPublish: false
    - task: PublishBuildArtifacts@1
      displayName: 'Publicar Artefactos de Back'
      inputs:
        pathtoPublish: '$(buildOutput)'
        artifactName: 'drop-back'
        publishLocation: 'Container'
    - task: PublishPipelineArtifact@1
      displayName: 'Publicar Dockerfile de Back'
      inputs:
        targetPath: '$(Build.SourcesDirectory)/docker/api/dockerfile'
        artifact: 'dockerfile-back'
  - job: Frontend
    displayName: 'Build y Análisis del Front-End'
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: '18.x'
      displayName: 'Instalar Node.js'
    - task: Cache@2
      inputs:
        key: 'npm | "$(Agent.OS)" | EmployeeCrudAngular/package-lock.json'
        path: 'EmployeeCrudAngular/EmployeeCrudAngular/EmployeeCrudAngular/node_modules'
        restoreKeys: |
          npm | "$(Agent.OS)"
      displayName: 'Cachear dependencias de npm'
    - task: CmdLine@2
      displayName: 'Instalar Dependencias de Front'
      inputs:
        script: npm install
        workingDirectory: '$(frontPath)'
    - task: CmdLine@2
      displayName: 'Build de Front'
      condition: succeeded()
      inputs:
        script: npx ng build --configuration production
        workingDirectory: '$(frontPath)'
    - task: PublishBuildArtifacts@1
      displayName: 'Publicar Artefactos de Front'
      inputs:
        pathtoPublish: '$(frontPath)/dist/employee-crud-angular/browser'
        artifactName: 'drop-front'
        publishLocation: 'Container'
    - task: PublishPipelineArtifact@1
      displayName: 'Publicar Dockerfile de Front'
      inputs:
        targetPath: '$(Build.SourcesDirectory)/docker/front/dockerfile'
        artifact: 'dockerfile-front'

- stage: DockerBuildAndPush
  displayName: 'Construir y Subir Imágenes Docker a ACR'
  dependsOn:

  - BuildAndTest
  jobs:
  - job: docker_build_and_push
    displayName: 'Construir y Subir Imágenes Docker de Back a ACR'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: DownloadPipelineArtifact@2
      displayName: 'Descargar Artefactos de Back'
      inputs:
        buildType: 'current'
        artifactName: 'drop-back'
        targetPath: '$(Pipeline.Workspace)/drop-back'
    - task: DownloadPipelineArtifact@2
      displayName: 'Descargar Dockerfile de Back'
      inputs:
        buildType: 'current'
        artifactName: 'dockerfile-back'
        targetPath: '$(Pipeline.Workspace)/dockerfile-back'
    - task: AzureCLI@2
      displayName: 'Iniciar Sesión en Azure Container Registry (ACR)'
      inputs:
        azureSubscription: '$(ConnectedServiceName)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          az acr login --name $(acrLoginServer)
    - task: Docker@2
      displayName: 'Construir Imagen Docker para Back'
      inputs:
        command: build
        repository: $(acrLoginServer)/$(backImageName)
        dockerfile: $(Pipeline.Workspace)/dockerfile-back/dockerfile
        buildContext: $(Pipeline.Workspace)/drop-back
        tags: 'latest'
    - task: Docker@2
      displayName: 'Subir Imagen Docker de Back a ACR'
      inputs:
        command: push
        repository: $(acrLoginServer)/$(backImageName)
        tags: 'latest'

  - job: docker_build_and_push_front
    displayName: 'Construir y Subir Imágenes Docker de Front a ACR'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: DownloadPipelineArtifact@2
      displayName: 'Descargar Artefactos de Front'
      inputs:
        buildType: 'current'
        artifactName: 'drop-front'
        targetPath: '$(Pipeline.Workspace)/drop-front'
    - task: DownloadPipelineArtifact@2
      displayName: 'Descargar Dockerfile de Front'
      inputs:
        buildType: 'current'
        artifactName: 'dockerfile-front'
        targetPath: '$(Pipeline.Workspace)/dockerfile-front'
    - task: AzureCLI@2
      displayName: 'Iniciar Sesión en Azure Container Registry (ACR)'
      inputs:
        azureSubscription: '$(ConnectedServiceName)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          az acr login --name $(acrLoginServer)
    - task: Docker@2
      displayName: 'Construir Imagen Docker para Front'
      inputs:
        command: build
        repository: $(acrLoginServer)/$(frontImageName)
        dockerfile: $(Pipeline.Workspace)/dockerfile-front/dockerfile
        buildContext: $(Pipeline.Workspace)/drop-front
        tags: 'latest'
    - task: Docker@2
      displayName: 'Subir Imagen Docker de Front a ACR'
      inputs:
        command: push
        repository: $(acrLoginServer)/$(frontImageName)
        tags: 'latest'

# Desplegar en Azure Container Instances (ACI) QA
- stage: DeployToACIQA
  displayName: 'Desplegar en Azure Container Instances (ACI) QA'
  dependsOn:
  - DockerBuildAndPush
  jobs:
  - job: deploy_to_aci_qa
    displayName: 'Desplegar en Azure Container Instances (ACI) QA'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: AzureCLI@2
      displayName: 'Desplegar Imagen Docker de Back en ACI QA'
      inputs:
        azureSubscription: '$(ConnectedServiceName)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          echo "Resource Group: $(ResourceGroupName)"
          echo "Container Instance Name: $(backContainerInstanceNameQA)"
          echo "ACR Login Server: $(acrLoginServer)"
          echo "Image Name: $(backImageName)"
          echo "Image Tag: $(backImageTag)"
          echo "Connection String: $(cnn-string-qa)"

          az container delete --resource-group $(ResourceGroupName) --name $(backContainerInstanceNameQA) --yes

          az container create --resource-group $(ResourceGroupName) \
            --name $(backContainerInstanceNameQA) \
            --image $(acrLoginServer)/$(backImageName):$(backImageTag) \
            --registry-login-server $(acrLoginServer) \
            --registry-username $(acrName) \
            --registry-password $(az acr credential show --name $(acrName) --query "passwords[0].value" -o tsv) \
            --dns-name-label $(backContainerInstanceNameQA) \
            --ports 80 \
            --environment-variables ConnectionStrings__DefaultConnection="$(cnn-string-qa)" \
            --restart-policy Always \
            --cpu $(container-cpu-api-qa) \
            --memory $(container-memory-api-qa)
  
    - task: AzureCLI@2
      displayName: 'Desplegar Imagen Docker de Front en ACI QA'
      inputs:
        azureSubscription: '$(ConnectedServiceName)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          echo "Resource Group: $(ResourceGroupName)"
          echo "Container Instance Name: $(frontContainerInstanceNameQA)"
          echo "ACR Login Server: $(acrLoginServer)"
          echo "Image Name: $(frontImageName)"
          echo "Image Tag: $(frontImageTag)"
          echo "Api Url: $(api_url)"

          az container delete --resource-group $(ResourceGroupName) --name $(frontContainerInstanceNameQA) --yes

          az container create --resource-group $(ResourceGroupName) \
            --name $(frontContainerInstanceNameQA) \
            --image $(acrLoginServer)/$(frontImageName):$(frontImageTag) \
            --registry-login-server $(acrLoginServer) \
            --registry-username $(acrName) \
            --registry-password $(az acr credential show --name $(acrName) --query "passwords[0].value" -o tsv) \
            --dns-name-label $(frontContainerInstanceNameQA) \
            --ports 80 \
            --environment-variables api_url="$(api_url)" \
            --restart-policy Always \
            --cpu $(container-cpu-front-qa) \
            --memory $(container-memory-front-qa)

  - job: IntegrationTesting
    displayName: 'Cypress'
    dependsOn: deploy_to_aci_qa
    variables:
      - name: baseUrl
        value: '$(frontContainerInstanceNameQA).eastus.azurecontainer.io'

    steps:
      - script: |
          cd $(Build.SourcesDirectory)/EmployeeCrudAngular
          npm install typescript ts-node
        displayName: 'Install TypeScript'

      # Crear la carpeta results si no existe
      - script: |
          mkdir $(Build.SourcesDirectory)\EmployeeCrudAngular\EmployeeCrudAngular\EmployeeCrudAngular\cypress\results
        displayName: 'Create Results Directory'

      - script: |
          cd $(Build.SourcesDirectory)/EmployeeCrudAngular/EmployeeCrudAngular/EmployeeCrudAngular
          npx cypress run --config-file cypress.config.ts --env baseUrl=$(baseUrl)
        displayName: 'Run Cypress E2E Tests'

      - task: PublishTestResults@2
        inputs:
          testResultsFiles: '$(Build.SourcesDirectory)/EmployeeCrudAngular/EmployeeCrudAngular/EmployeeCrudAngular/cypress/results/*.xml'
          testRunTitle: 'Cypress E2E Tests (QA)'
        displayName: 'Publish Cypress Test Results'
